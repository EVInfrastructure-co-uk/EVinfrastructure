---
layout: default
title: "Local authority maps"
---

<head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    /* ensure all three map containers have height */
    #map-levi, #map-pavement, #map-nearhome { height: 80vh; }
    .legend { background: white; padding: 6px 8px; font: 12px/1.5 sans-serif; box-shadow:0 0 8px rgba(0,0,0,0.2); }
    .legend .swatch { width:18px; height:12px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .row { margin-bottom:4px; white-space:nowrap; }
  </style>
</head>

<h1>Maps of local authorities</h1>

<div class="tabs js-tabs" data-module="tabs">
  <div class="tabs__controls" role="tablist" aria-label="Section">

    <button id="tab-near-home" class="tabs__tab tabs__tab--active" role="tab"
            aria-selected="true" aria-controls="near-home" tabindex="0">
      Near home charging
    </button>

    <button id="tab-pavement-channels" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="pavement-channels" tabindex="-1">
      Pavement channels
    </button>

    <button id="tab-levi" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="levi" tabindex="-1">
      LEVI/EVIF/ULEVTF
    </button>
  </div>

  <div id="near-home" class="tabs__panel" role="tabpanel" aria-labelledby="tab-near-home">
    <h2>NEVIS Near Home Charging distribution metric</h2>

    <p>The below figures show the percentage of households without driveways which are within a 4-minute walk of public chargepoints.</p>

    <div id="map-nearhome" aria-label="Map of UK local authorities coloured by NEVIS near home charging distribution (deciles)">
    </div>
    <p>This is a repeat of the map which is on the <a href="https://nevis.cenex.co.uk/metrics">National EV Insights and Supports website</a>.</p>
    <p>Data not available for Northern Ireland.</p>
  </div>

  <div id="pavement-channels" class="tabs__panel" role="tabpanel" aria-labelledby="tab-pavement-channels">
    <h2>Pavement Channels</h2>

    <!-- New pavement map container -->
    <div id="map-pavement" aria-label="Pavement channels map — local authorities coloured by channel status or grant amount">
    </div>
    <p>The Department for Transport publishes <a href="https://www.gov.uk/government/publications/electric-vehicle-ev-pavement-channels-grant-local-authority-allocations/electric-vehicle-ev-pavement-channels-grant-funding-amounts">information</a> on the Pavement Chanel Grant by authority.</p>
    <p>Please note that some combined authorities are recipients of the Pavement Channel Grant. The above map shows highway authorities instead of combined authorities because highway authorities are responsible for decisions on pavement channels. (Devon and Torbay is an exception as they have characterised their channel trial as cross-boundary.)</p>
  </div>

  <div id="levi" class="tabs__panel" role="tabpanel" aria-labelledby="tab-levi">
    <h2>Local Electric Vehicle Infrastructure fund (LEVI, England),<br>Electric Vehicle Infrastructure Fund (EVIF, Scotland)<br>Ultra Low Emission Vehicle Transformation Fund (ULEVTF, Wales)</h2>

    <!-- LEVI map container -->
    <div id="map-levi" aria-label="LEVI/EVIF/ULEVTF map — local authorities coloured by ORCS/LEVI metric (deciles)"></div>
  </div>
  <p>There is no equivalent scheme in <a href="https://evinfrastructure.co.uk/government/ni#funding-public-chargepoints">Northern Ireland</a> although nine of the eleven councils are in a consortium funded by both the UK government and the NI executive. The consortium appointed Weev as chargepoint operator in 2025.</p>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>

<script>
(async function () {
  // CONFIG - distinct topojsons for each tab
  const topoNearPath = '/government/local-government/data/GBlocalauthorities.topojson';
  const topoPavementPath = '/government/local-government/data/pavementchannelauthorities.topojson';
  const topoLeviPath = '/government/local-government/data/LEVI-EVIF-ULEVTF-authorities.topojson';
  const eviJsonPath = '/government/local-government/data/uk_la_evi.json';

  try {
    // Load all three topology files and the EVI json in parallel
    const [topoNearResp, topoPavResp, topoLeviResp, eviResp] = await Promise.all([
      fetch(topoNearPath),
      fetch(topoPavementPath),
      fetch(topoLeviPath),
      fetch(eviJsonPath)
    ]);

    if (!topoNearResp.ok) throw new Error('Near-home TopoJSON load failed: ' + topoNearResp.status);
    if (!topoPavResp.ok) throw new Error('Pavement TopoJSON load failed: ' + topoPavResp.status);
    if (!topoLeviResp.ok) throw new Error('LEVI TopoJSON load failed: ' + topoLeviResp.status);
    if (!eviResp.ok) throw new Error('EVI JSON load failed: ' + eviResp.status);

    const [topoNear, topoPav, topoLevi, eviBundle] = await Promise.all([
      topoNearResp.json(),
      topoPavResp.json(),
      topoLeviResp.json(),
      eviResp.json()
    ]);

    // helper to pick the first object name in a topojson (robust if different object names)
    function topoFirstObjectName(topo) {
      const keys = Object.keys(topo.objects || {});
      return keys.length ? keys[0] : null;
    }

    // Convert each topology to GeoJSON FeatureCollection
    const nearObjName = topoFirstObjectName(topoNear);
    const pavObjName = topoFirstObjectName(topoPav);
    const leviObjName = topoFirstObjectName(topoLevi);
    if (!nearObjName || !pavObjName || !leviObjName) throw new Error('One of the topojson files has no objects');

    const geoNear = topojson.feature(topoNear, topoNear.objects[nearObjName]);
    const geoPav = topojson.feature(topoPav, topoPav.objects[pavObjName]);
    const geoLevi = topojson.feature(topoLevi, topoLevi.objects[leviObjName]);

    // Find resource row table in eviBundle
    const resource = (eviBundle.resources && eviBundle.resources.find(r => r.name === 'uk_local_authorities_current')) || (eviBundle.resources && eviBundle.resources[0]);
    if (!resource || !resource.data) throw new Error('Could not find resource.data in the EVI JSON');
    const rows = resource.data;

    // Build two lookup maps: by gss-code and by local-authority-code
    const rowByGss = new Map();
    const rowByLocal = new Map();
    rows.forEach(r => {
      if (r['gss-code']) rowByGss.set(String(r['gss-code']).trim(), r);
      if (r['local-authority-code']) rowByLocal.set(String(r['local-authority-code']).trim(), r);
    });

    // Generic helper to find the matching row for a topojson feature.
    // It tries several possible properties for GSS or local-authority-code and returns the row or null.
    function getRowForFeature(feature) {
      const p = (feature && feature.properties) ? feature.properties : {};
      const candidates = [];

      // common gss-like fields
      ['LAD24CD','CTYUA24CD','gss','gss_code','gss-code','GSS_CODE','GSS'].forEach(k=>{
        if (p[k]) candidates.push(String(p[k]).trim());
      });

      // common local-authority-code fields
      ['local-authority-code','local_authority_code','localAuthorityCode','LAD24CD'].forEach(k=>{
        if (p[k]) candidates.push(String(p[k]).trim());
      });

      // Also consider any property whose key contains 'gss' or 'lad' or 'local' (best-effort)
      Object.keys(p).forEach(k => {
        const lk = k.toLowerCase();
        if ((lk.includes('gss') || lk.includes('lad') || lk.includes('local')) && p[k]) {
          candidates.push(String(p[k]).trim());
        }
      });

      for (const c of candidates) {
        if (!c) continue;
        if (rowByGss.has(c)) return rowByGss.get(c);
        if (rowByLocal.has(c)) return rowByLocal.get(c);
      }
      return null;
    }

    // Utility to convert possibly-null values to numbers; NaN for missing
    function toNum(v) {
      if (v === null || v === undefined || v === '') return NaN;
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    // ------------------------
    // NEVIS map (deciles)
    // ------------------------

    // Gather numeric NEVIS values from rows
    const nearhomeValues = rows.map(r => toNum(r['NEVIS-distribution'])).filter(v => !isNaN(v)).sort((a,b)=>a-b);

    function quantile(sortedArr, p) {
      if (!sortedArr.length) return NaN;
      const idx = (sortedArr.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if (hi === lo) return sortedArr[lo];
      const frac = idx - lo;
      return sortedArr[lo] * (1 - frac) + sortedArr[hi] * frac;
    }

    const nearhomeThresholds = [];
    if (nearhomeValues.length) for (let i = 1; i <= 9; i++) nearhomeThresholds.push(quantile(nearhomeValues, i / 10));
    const nearhomePalette = chroma.scale('YlGnBu').mode('lab').colors(10);
    function nearhomeDecileIndex(v) {
      if (isNaN(v)) return -1;
      for (let i = 0; i < nearhomeThresholds.length; i++) if (v <= nearhomeThresholds[i]) return i;
      return 9;
    }

    const mapNearHome = L.map('map-nearhome').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; CENEX NEVIS 2025; Office for National Statistics licensed under the Open Government Licence v.3.0 (Contains OS data © Crown copyright and database right 2024); &copy; OpenStreetMap contributors'
    }).addTo(mapNearHome);
    window.nearhomeMap = mapNearHome;

    const nearhomeLayer = L.geoJSON(geoNear, {
      style(feature) {
        const row = getRowForFeature(feature);
        const v = row ? toNum(row['NEVIS-distribution']) : NaN;
        const idx = nearhomeDecileIndex(v);
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: idx === -1 ? 0.15 : 0.85,
          fillColor: idx === -1 ? '#cccccc' : nearhomePalette[idx]
        };
      },
      onEachFeature(feature, layer) {
        const row = getRowForFeature(feature);
        const name = (feature.properties && (feature.properties.LAD24NM || feature.properties.name || feature.properties.CTYUA24NM)) || (row && (row['official-name'] || row['nice-name'])) || 'Unknown';
        const slug = row ? row['gov-uk-slug'] : null;
        const v = row ? row['NEVIS-distribution'] : null;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>NEVIS Near Home distribution: ${isNaN(toNum(v)) ? 'N/A' : v}<br/><a href="/government/local-government/${slug}">See our dedicated page</a>`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            nearhomeLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapNearHome.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapNearHome);

    // Near home legend
    const nearhomeLegend = L.control({ position: 'bottomright' });
    nearhomeLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'Near home decile legend');
      if (!nearhomeValues.length) { div.innerHTML = '<strong>NEVIS Near Home distribution</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>NEVIS Near home distribution (deciles)</strong><br/>';
      let lower = nearhomeValues[0];
      for (let i = 0; i < 10; i++) {
        const color = nearhomePalette[i];
        const upper = (i < 9) ? nearhomeThresholds[i] : nearhomeValues[nearhomeValues.length - 1];
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${Math.round(lower)} – ${Math.round(upper)}`;
        div.appendChild(row);
        lower = (i < 9) ? (nearhomeThresholds[i] + Number.EPSILON) : upper;
      }
      const nodata = document.createElement('div');
      nodata.className = 'row';
      nodata.style.marginTop = '6px';
      nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
      div.appendChild(nodata);
      return div;
    };
    nearhomeLegend.addTo(mapNearHome);

    // ------------------------
    // LEVI/ORCS map (deciles) - previously "ORCS map" - now rendered in LEVI tab using its own topojson
    // ------------------------

    const orcsValues = rows.map(r => toNum(r['ORCS-total-charging-devices'])).filter(v => !isNaN(v)).sort((a,b)=>a-b);
    const orcsThresholds = [];
    if (orcsValues.length) for (let i = 1; i <= 9; i++) orcsThresholds.push(quantile(orcsValues, i / 10));
    const orcsPalette = chroma.scale('YlGnBu').mode('lab').colors(10);
    function orcsDecileIndex(v) {
      if (isNaN(v)) return -1;
      for (let i = 0; i < orcsThresholds.length; i++) if (v <= orcsThresholds[i]) return i;
      return 9;
    }

    const mapLevi = L.map('map-levi').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Office for National Statistics licensed under the Open Government Licence v.3.0 (Contains OS data © Crown copyright and database right 2024); &copy; OpenStreetMap contributors'
    }).addTo(mapLevi);
    window.leviMap = mapLevi;

    const leviLayer = L.geoJSON(geoLevi, {
      style(feature) {
        const row = getRowForFeature(feature);
        const v = row ? toNum(row['ORCS-total-charging-devices']) : NaN;
        const idx = orcsDecileIndex(v);
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: idx === -1 ? 0.15 : 0.85,
          fillColor: idx === -1 ? '#cccccc' : orcsPalette[idx]
        };
      },
      onEachFeature(feature, layer) {
        const row = getRowForFeature(feature);
        const name = (feature.properties && (feature.properties.LAD24NM || feature.properties.name || feature.properties.CTYUA24NM)) || (row && (row['official-name'] || row['nice-name'])) || 'Unknown';
        const slug = row ? row['gov-uk-slug'] : null;
        const v = row ? row['ORCS-total-charging-devices'] : null;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>ORCS devices: ${isNaN(toNum(v)) ? 'N/A' : v}<br/><a href="/government/local-government/${slug}">See our dedicated page</a>`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            leviLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapLevi.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapLevi);

    // ORCS (LEVI tab) legend
    const orcsLegend = L.control({ position: 'bottomright' });
    orcsLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'ORCS devices decile legend');
      if (!orcsValues.length) { div.innerHTML = '<strong>ORCS devices</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>ORCS devices (deciles)</strong><br/>';
      let lower = orcsValues[0];
      for (let i = 0; i < 10; i++) {
        const color = orcsPalette[i];
        const upper = (i < 9) ? orcsThresholds[i] : orcsValues[orcsValues.length - 1];
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${Math.round(lower)} – ${Math.round(upper)}`;
        div.appendChild(row);
        lower = (i < 9) ? (orcsThresholds[i] + Number.EPSILON) : upper;
      }
      const nodata = document.createElement('div');
      nodata.className = 'row';
      nodata.style.marginTop = '6px';
      nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
      div.appendChild(nodata);
      return div;
    };
    orcsLegend.addTo(mapLevi);

    // ------------------------
    // Pavement Channels map (categorical by channel-status)
    // ------------------------

    // Build status mapping (row-based) and collect distinct statuses
    const statusesSet = new Set();
    rows.forEach(r => {
      let status = r['channel-status'];
      if (status === null || status === undefined || status === '') status = 'No data';
      status = String(status).trim();
      statusesSet.add(status);
    });
    const statuses = Array.from(statusesSet).sort();
    const baseColors = [
      '#1f78b4', '#33a02c', '#e31a1c', '#ff7f00',
      '#6a3d9a', '#b15928', '#a6cee3', '#b2df8a',
      '#fb9a99', '#fdbf6f', '#cab2d6', '#ffff99'
    ];
    const statusColor = {};
    statuses.forEach((s, i) => {
      statusColor[s] = baseColors[i % baseColors.length];
    });

    const mapPav = L.map('map-pavement').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Department for Transport; Office for National Statistics licensed under the Open Government Licence v.3.0 (Contains OS data © Crown copyright and database right 2024); &copy; OpenStreetMap contributors'
    }).addTo(mapPav);
    window.pavementMap = mapPav;

    const pavLayer = L.geoJSON(geoPav, {
      style(feature) {
        const row = getRowForFeature(feature);
        const status = row ? (row['channel-status'] ? String(row['channel-status']).trim() : 'No data') : 'No data';
        const color = statusColor[status] || '#cccccc';
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: status === 'No data' ? 0.15 : 0.85,
          fillColor: color
        };
      },
      onEachFeature(feature, layer) {
        const row = getRowForFeature(feature);
        const name = (feature.properties && (feature.properties.LAD24NM || feature.properties.name || feature.properties.CTYUA24NM)) || (row && (row['official-name'] || row['nice-name'])) || 'Unknown';
        const status = row ? (row['channel-status'] ? String(row['channel-status']).trim() : 'No data') : 'No data';
        const grant = row ? row['channel-grant-amount'] : null;
        const slug = row ? row['gov-uk-slug'] : null;
        const grantLabel = (grant === null || grant === undefined || grant === '') ? '' : `<br/>Grant amount: £${Number(grant).toLocaleString()}`;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>Status: ${status}${grantLabel}<br/><a href="/government/local-government/${slug}">See our dedicated page</a>`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            pavLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapPav.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapPav);

    // Pavement legend — categorical
    const pavLegend = L.control({ position: 'bottomright' });
    pavLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'Pavement channels status legend');
      if (!statuses.length) { div.innerHTML = '<strong>Pavement channels</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>Pavement channels</strong><br/>';
      statuses.forEach(s => {
        const color = statusColor[s] || '#cccccc';
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${s}`;
        div.appendChild(row);
      });
      if (!statuses.includes('No data')) {
        const nodata = document.createElement('div');
        nodata.className = 'row';
        nodata.style.marginTop = '6px';
        nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
        div.appendChild(nodata);
      }
      return div;
    };
    pavLegend.addTo(mapPav);

    // Tab invalidation hooks
    function hookTabInvalidate(tabId, mapObj) {
      const btn = document.getElementById(tabId);
      if (!btn) return;
      btn.addEventListener('click', () => {
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      });
      if (btn.classList.contains('tabs__tab--active') || btn.getAttribute('aria-selected') === 'true') {
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      }
    }
    hookTabInvalidate('tab-near-home', mapNearHome);
    hookTabInvalidate('tab-pavement-channels', mapPav);
    hookTabInvalidate('tab-levi', mapLevi);

  } catch (err) {
    console.error(err);
    alert('Map initialization failed: ' + (err && err.message));
  }
})();
</script>

<script type="text/javascript" src="/js/tabs.js"></script>