---
layout: default
title: "Local authority maps"
---

<head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    /* ensure all three map containers have height */
    #map-levi, #map-pavement, #map-nearhome { height: 80vh; }
    .legend { background: white; padding: 6px 8px; font: 12px/1.5 sans-serif; box-shadow:0 0 8px rgba(0,0,0,0.2); }
    .legend .swatch { width:18px; height:12px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .row { margin-bottom:4px; white-space:nowrap; }
    .legend .gradient { height:12px; width:160px; background:linear-gradient(to right, red, orange, green); display:block; margin:6px 0; border:1px solid #ccc; }
  </style>
</head>

<h1>Maps of local authorities</h1>

<div class="tabs js-tabs" data-module="tabs">
  <div class="tabs__controls" role="tablist" aria-label="Section">

    <button id="tab-near-home" class="tabs__tab tabs__tab--active" role="tab"
            aria-selected="true" aria-controls="near-home" tabindex="0">
      Near home charging
    </button>

    <button id="tab-pavement-channels" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="pavement-channels" tabindex="-1">
      Pavement channels
    </button>

    <button id="tab-levi" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="levi" tabindex="-1">
      LEVI/EVIF/ULEVTF
    </button>
  </div>

  <div id="near-home" class="tabs__panel" role="tabpanel" aria-labelledby="tab-near-home">
    <h2>NEVIS Near Home Charging distribution metric</h2>

    <div id="map-nearhome" aria-label="Map of UK local authorities coloured by NEVIS near home charging distribution (continuous red–amber–green)">
  </div>

  </div>

  <div id="pavement-channels" class="tabs__panel" role="tabpanel" aria-labelledby="tab-pavement-channels">
    <h2>Pavement Channels</h2>

    <!-- Pavement map container -->
    <div id="map-pavement" aria-label="Pavement channels map — local authorities coloured by channel status or grant amount"></div>
  </div>

  <div id="levi" class="tabs__panel" role="tabpanel" aria-labelledby="tab-levi">
    <h2>Local Electric Vehicle Infrastructure fund (LEVI, England),<br>Electric Vehicle Infrastructure Fund (EVIF, Scotland)<br>Ultra Low Emission Vehicle Transformation Fund (ULEVTF, Wales)</h2>

    <!-- LEVI map container -->
    <div id="map-levi" aria-label="LEVI/EVIF/ULEVTF map — local authorities coloured by LEVI-tender-stage"></div>
  </div>

</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>

<script>
(async function () {
  // CONFIG
  const topojsonPath = '/government/local-government/data/localauthorities.topojson';
  const eviJsonPath = '/government/local-government/data/uk_la_evi.json';
  const topoObjectName = 'localauthorities';

  try {
    // Load both resources in parallel
    const [topoResp, eviResp] = await Promise.all([
      fetch(topojsonPath),
      fetch(eviJsonPath)
    ]);
    if (!topoResp.ok) throw new Error('TopoJSON load failed: ' + topoResp.status);
    if (!eviResp.ok) throw new Error('EVI JSON load failed: ' + eviResp.status);
    const topo = await topoResp.json();
    const eviBundle = await eviResp.json();

    // Convert topology to geojson features
    const geojson = topojson.feature(topo, topo.objects[topoObjectName]);

    // Find resource row table
    const resource = (eviBundle.resources && eviBundle.resources.find(r => r.name === 'uk_local_authorities_current')) || (eviBundle.resources && eviBundle.resources[0]);
    if (!resource || !resource.data) throw new Error('Could not find resource.data in the EVI JSON');
    const rows = resource.data;

    // Build lookups: by gss-code and by local-authority-code (fallback)
    const rowByGss = new Map();
    const rowByLocal = new Map();
    rows.forEach(r => {
      if (r['gss-code']) rowByGss.set(String(r['gss-code']).trim(), r);
      if (r['local-authority-code']) rowByLocal.set(String(r['local-authority-code']).trim(), r);
    });

    // Helper to find Row for a topojson feature: try GSS-like properties then local-authority-code
    function getRowForFeature(feature) {
      const p = (feature && feature.properties) ? feature.properties : {};
      const candKeys = ['LAD24CD','CTYUA24CD','gss','gss_code','gss-code','GSS_CODE','GSS'];
      for (const k of candKeys) {
        if (p[k]) {
          const val = String(p[k]).trim();
          if (rowByGss.has(val)) return rowByGss.get(val);
          if (rowByLocal.has(val)) return rowByLocal.get(val);
        }
      }
      // fallback: look for local-authority-code-like properties
      const localKeys = ['local-authority-code','local_authority_code','localAuthorityCode','code','LAD24CD'];
      for (const k of localKeys) {
        if (p[k]) {
          const val = String(p[k]).trim();
          if (rowByLocal.has(val)) return rowByLocal.get(val);
          if (rowByGss.has(val)) return rowByGss.get(val);
        }
      }
      // best-effort: check any property names for 'gss'/'lad'/'local'
      for (const k of Object.keys(p)) {
        const lk = k.toLowerCase();
        if ((lk.includes('gss') || lk.includes('lad') || lk.includes('local') || lk.includes('code')) && p[k]) {
          const val = String(p[k]).trim();
          if (rowByGss.has(val)) return rowByGss.get(val);
          if (rowByLocal.has(val)) return rowByLocal.get(val);
        }
      }
      return null;
    }

    // Utility to convert possibly-null values to numbers; NaN for missing
    function toNum(v) {
      if (v === null || v === undefined || v === '') return NaN;
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    // ------------------------
    // NEVIS map (continuous red->amber->green)
    // ------------------------

    // Build NEVIS numeric array
    const nearhomeValues = rows.map(r => toNum(r['NEVIS-distribution'])).filter(v => !isNaN(v)).sort((a,b)=>a-b);

    // continuous colour scale: red -> amber -> green mapped over 0..100
    const nearScale = chroma.scale(['#d7191c', '#fdae61', '#1a9641']).mode('lab').domain([0,100]);

    const mapNearHome = L.map('map-nearhome').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(mapNearHome);
    window.nearhomeMap = mapNearHome; // expose for tab invalidation

    const nearhomeLayer = L.geoJSON(geojson, {
      style(feature) {
        const row = getRowForFeature(feature);
        const v = row ? toNum(row['NEVIS-distribution']) : NaN;
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: isNaN(v) ? 0.15 : 0.85,
          fillColor: isNaN(v) ? '#cccccc' : nearScale(Math.max(0, Math.min(100, v))).hex()
        };
      },
      onEachFeature(feature, layer) {
        const row = getRowForFeature(feature);
        const name = feature.properties && (feature.properties.LAD24NM || feature.properties.name || 'Unknown');
        const v = row ? row['NEVIS-distribution'] : null;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>NEVIS Near Home distribution: ${isNaN(toNum(v)) ? 'N/A' : v}`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            nearhomeLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapNearHome.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapNearHome);

    // Near home legend (continuous)
    const nearhomeLegend = L.control({ position: 'bottomright' });
    nearhomeLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'Near home continuous legend');
      div.innerHTML = '<strong>NEVIS Near home distribution</strong><br/>';
      // gradient bar
      const grad = document.createElement('div');
      grad.className = 'gradient';
      // create a canvas-like gradient using inline style consistent with the colour scale
      // fallback gradient uses same colours as nearScale
      grad.style.background = 'linear-gradient(to right, #d7191c, #fdae61, #1a9641)';
      div.appendChild(grad);
      // labels
      const lbls = document.createElement('div');
      lbls.style.display = 'flex';
      lbls.style.justifyContent = 'space-between';
      lbls.style.fontSize = '11px';
      lbls.innerHTML = '<span>0</span><span>50</span><span>100</span>';
      div.appendChild(lbls);
      const nodata = document.createElement('div');
      nodata.className = 'row';
      nodata.style.marginTop = '6px';
      nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
      div.appendChild(nodata);
      return div;
    };
    nearhomeLegend.addTo(mapNearHome);


    // ------------------------
    // Pavement Channels map (categorical)
    // - "Permitted" -> dark green
    // - "Not permitted" -> red
    // - values containing "trial" (case-insensitive) -> various shades of amber
    // ------------------------

    // Build status mapping (gss -> status) and collect distinct statuses
    const statusByGss = new Map();
    const statusesSet = new Set();
    rows.forEach(r => {
      const gss = r['gss-code'];
      let status = r['channel-status'];
      if (status === null || status === undefined || status === '') status = 'No data';
      status = String(status).trim();
      statusByGss.set(gss, status);
      statusesSet.add(status);
    });

    const statuses = Array.from(statusesSet).sort();
    // palettes
    const amberPalette = ['#ffb84d', '#ffbf66', '#ffc87f', '#ffd399']; // various ambers
    const redPalette = ['#a50f15','#d73027','#f46d43','#fdae61']; // shades of red
    const permittedColor = '#006400'; // dark green
    const notPermittedColor = '#d73027'; // red

    // Build status->colour mapping
    const statusColor = {};
    statuses.forEach((s, i) => {
      const sl = s.toLowerCase();
      if (s === 'Permitted' || sl === 'permitted') {
        statusColor[s] = permittedColor;
      } else if (s === 'Not permitted' || sl === 'not permitted' || sl === 'not-permitted') {
        statusColor[s] = notPermittedColor;
      } else if (sl.includes('trial')) {
        // pick an amber shade based on index among trial statuses
        // find all statuses that include 'trial' and map consistently
        const trialStatuses = statuses.filter(ss => ss.toLowerCase().includes('trial'));
        const idx = trialStatuses.indexOf(s);
        statusColor[s] = amberPalette[idx % amberPalette.length];
      } else if (s === 'No data') {
        statusColor[s] = '#cccccc';
      } else {
        // other values -> shades of red, choose by index among "other" statuses
        const otherStatuses = statuses.filter(ss => {
          const l = ss.toLowerCase();
          return !(l === 'permitted' || l === 'not permitted' || l.includes('trial') || ss === 'No data');
        });
        const idx = otherStatuses.indexOf(s);
        statusColor[s] = redPalette[idx % redPalette.length] || '#d73027';
      }
    });

    const mapPav = L.map('map-pavement').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(mapPav);
    window.pavementMap = mapPav;

    const pavLayer = L.geoJSON(geojson, {
      style(feature) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const status = statusByGss.get(code) || 'No data';
        const color = statusColor[status] || '#cccccc';
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: status === 'No data' ? 0.15 : 0.85,
          fillColor: color
        };
      },
      onEachFeature(feature, layer) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const name = feature.properties && (feature.properties.LAD24NM || feature.properties.name || 'Unknown');
        const status = statusByGss.get(code) || 'No data';
        // include grant amount if present
        // try to find the row by code (gss) or fallback to local-authority-code via getRowForFeature
        const row = rowByGss.get(code) || getRowForFeature(feature) || {};
        const grant = row['channel-grant-amount'];
        const grantLabel = (grant === null || grant === undefined || grant === '') ? '' : `<br/>Grant amount: £${Number(grant).toLocaleString()}`;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>Status: ${status}${grantLabel}`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            pavLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapPav.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapPav);

    // Pavement legend — categorical
    const pavLegend = L.control({ position: 'bottomright' });
    pavLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'Pavement channels status legend');
      if (!statuses.length) { div.innerHTML = '<strong>Pavement channels</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>Pavement channels</strong><br/>';
      // show Permitted first, Not permitted second, then trials, then others
      const ordered = [];
      if (statuses.includes('Permitted')) ordered.push('Permitted');
      if (statuses.includes('Not permitted')) ordered.push('Not permitted');
      statuses.filter(s => s.toLowerCase().includes('trial')).forEach(s => ordered.push(s));
      statuses.filter(s => !ordered.includes(s) && s !== 'No data').forEach(s => ordered.push(s));
      if (!ordered.includes('No data')) ordered.push('No data');

      ordered.forEach(s => {
        const color = statusColor[s] || '#cccccc';
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${s}`;
        div.appendChild(row);
      });
      return div;
    };
    pavLegend.addTo(mapPav);


    // ------------------------
    // LEVI map — categorical by LEVI-tender-stage
    // - "Awarded" => dark green
    // - "Yet to award" => light green
    // - "Tender live" => amber
    // - other values => shades of red
    // ------------------------

    // collect tender-stage values from rows
    const tenderStagesSet = new Set();
    rows.forEach(r => {
      let s = r['LEVI-tender-stage'];
      if (s === null || s === undefined || s === '') s = 'No data';
      tenderStagesSet.add(String(s).trim());
    });
    const tenderStages = Array.from(tenderStagesSet).sort();

    const leviColorMap = {};
    const darkGreen = '#006400';
    const lightGreen = '#8bc34a';
    const amber = '#ffbf00';
    const otherReds = ['#a50f15','#d73027','#f46d43','#fdae61'];

    tenderStages.forEach((stage, i) => {
      const sl = String(stage).trim();
      if (sl.toLowerCase() === 'awarded') {
        leviColorMap[stage] = darkGreen;
      } else if (sl.toLowerCase() === 'yet to award' || sl.toLowerCase() === 'yet to be awarded' || sl.toLowerCase() === 'yet to award ') {
        leviColorMap[stage] = lightGreen;
      } else if (sl.toLowerCase().includes('tender live') || sl.toLowerCase().includes('tender')) {
        leviColorMap[stage] = amber;
      } else if (sl === 'No data') {
        leviColorMap[stage] = '#cccccc';
      } else {
        // other -> shades of red
        const otherIdx = tenderStages.filter(ss => !['awarded','yet to award','no data'].includes(String(ss).toLowerCase()) && !String(ss).toLowerCase().includes('tender')).indexOf(stage);
        leviColorMap[stage] = otherReds[(otherIdx >= 0 ? otherIdx : i) % otherReds.length];
      }
    });

    const mapLevi = L.map('map-levi').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(mapLevi);
    window.leviMap = mapLevi;

    const leviLayer = L.geoJSON(geojson, {
      style(feature) {
        const row = getRowForFeature(feature);
        const stage = row ? (row['LEVI-tender-stage'] === null || row['LEVI-tender-stage'] === undefined || row['LEVI-tender-stage'] === '' ? 'No data' : String(row['LEVI-tender-stage']).trim()) : 'No data';
        const color = leviColorMap[stage] || '#d73027';
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: stage === 'No data' ? 0.15 : 0.85,
          fillColor: color
        };
      },
      onEachFeature(feature, layer) {
        const row = getRowForFeature(feature);
        const name = feature.properties && (feature.properties.LAD24NM || feature.properties.name || 'Unknown');
        const stage = row ? (row['LEVI-tender-stage'] === null || row['LEVI-tender-stage'] === undefined || row['LEVI-tender-stage'] === '' ? 'No data' : String(row['LEVI-tender-stage']).trim()) : 'No data';
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>LEVI tender stage: ${stage}`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            leviLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapLevi.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapLevi);

    // LEVI legend (categorical)
    const leviLegend = L.control({ position: 'bottomright' });
    leviLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'LEVI tender stage legend');
      if (!tenderStages.length) { div.innerHTML = '<strong>LEVI tender stage</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>LEVI tender stage</strong><br/>';
      // Order: Awarded, Yet to award, Tender live, then others
      const ordered = [];
      tenderStages.forEach(s => { if (String(s).toLowerCase() === 'awarded') ordered.push(s); });
      tenderStages.forEach(s => { if (String(s).toLowerCase() === 'yet to award' || String(s).toLowerCase().includes('yet to')) ordered.push(s); });
      tenderStages.forEach(s => { if (String(s).toLowerCase().includes('tender')) ordered.push(s); });
      tenderStages.forEach(s => { if (!ordered.includes(s)) ordered.push(s); });

      ordered.forEach(s => {
        const color = leviColorMap[s] || '#d73027';
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${s}`;
        div.appendChild(row);
      });
      return div;
    };
    leviLegend.addTo(mapLevi);


    // Handle tab show behaviour: invalidate map size after tab is displayed.
    function hookTabInvalidate(tabId, mapObj) {
      const btn = document.getElementById(tabId);
      if (!btn) return;
      btn.addEventListener('click', () => {
        // small delay to allow tab content to become visible
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      });
      // If tab already active on load
      if (btn.classList.contains('tabs__tab--active') || btn.getAttribute('aria-selected') === 'true') {
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      }
    }
    hookTabInvalidate('tab-near-home', mapNearHome);
    hookTabInvalidate('tab-pavement-channels', mapPav);
    hookTabInvalidate('tab-levi', mapLevi);

  } catch (err) {
    console.error(err);
    alert('Map initialization failed: ' + (err && err.message));
  }
})();
</script>

<script type="text/javascript" src="/js/tabs.js"></script>