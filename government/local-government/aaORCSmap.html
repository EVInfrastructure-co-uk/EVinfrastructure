---
layout: default
title: "UK LAs — ORCS charging devices"
---

<head>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    /* ensure both map containers have height */
    #map-orcs, #map-pavement { height: 80vh; }
    .legend { background: white; padding: 6px 8px; font: 12px/1.5 sans-serif; box-shadow:0 0 8px rgba(0,0,0,0.2); }
    .legend .swatch { width:18px; height:12px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .row { margin-bottom:4px; white-space:nowrap; }
  </style>
</head>

<h1>Maps of local authorities</h1>

<div class="tabs js-tabs" data-module="tabs">
  <div class="tabs__controls" role="tablist" aria-label="Section">

    <button id="tab-near-home" class="tabs__tab tabs__tab--active" role="tab"
            aria-selected="true" aria-controls="near-home" tabindex="0">
      Near home charging
    </button>

    <button id="tab-pavement-channels" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="pavement-channels" tabindex="-1">
      Pavement channels
    </button>

    <button id="tab-levi" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="levi" tabindex="-1">
      LEVI/EVIF/ULEVTF
    </button>

    <button id="tab-orcs" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="orcs" tabindex="-1">
      ORCS
    </button>

    <button id="tab-levi-pilot" class="tabs__tab" role="tab"
            aria-selected="false" aria-controls="levi-pilot" tabindex="-1">
      LEVI pilot
    </button>
  </div>

  <div id="near-home" class="tabs__panel" role="tabpanel" aria-labelledby="tab-near-home">
    <h2>NEVIS Near Home Charging distribution metric</h2>
  </div>

  <div id="pavement-channels" class="tabs__panel" role="tabpanel" aria-labelledby="tab-pavement-channels">
    <h2>Pavement Channels</h2>

    <!-- New pavement map container -->
    <div id="map-pavement" aria-label="Pavement channels map — local authorities coloured by channel status or grant amount"></div>
  </div>

  <div id="levi" class="tabs__panel" role="tabpanel" aria-labelledby="tab-levi">
    <h2>Local Electric Vehicle Infrastructure fund (LEVI, England),<br>Electric Vehicle Infrastructure Fund (EVIF, Scotland)<br>Ultra Low Emission Vehicle Transformation Fund (ULEVTF, Wales)</h2>
  </div>

  <div id="orcs" class="tabs__panel" role="tabpanel" aria-labelledby="tab-orcs">
    <h2>On-Street Charging Scheme (ORCS)</h2>

    <div id="map-orcs" aria-label="Map of UK local authorities coloured by ORCS charging devices (deciles)"></div>
  </div>

  <div id="levi-pilot" class="tabs__panel" role="tabpanel" aria-labelledby="tab-levi-pilot">
    <h3>Local Electric Vehicle Infrastructure Fund Pilot (England only)</h3>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>

<script>
(async function () {
  // CONFIG
  const topojsonPath = '/government/local-government/data/LAD_DEC_24_UK_BSC_-416161531269609018.topojson';
  const eviJsonPath = '/government/local-government/data/uk_la_evi.json';
  const topoObjectName = 'LAD_DEC_24_UK_BSC_-416161531269609018';

  try {
    // Load both resources in parallel
    const [topoResp, eviResp] = await Promise.all([
      fetch(topojsonPath),
      fetch(eviJsonPath)
    ]);
    if (!topoResp.ok) throw new Error('TopoJSON load failed: ' + topoResp.status);
    if (!eviResp.ok) throw new Error('EVI JSON load failed: ' + eviResp.status);
    const topo = await topoResp.json();
    const eviBundle = await eviResp.json();

    // Convert topology to geojson features
    const geojson = topojson.feature(topo, topo.objects[topoObjectName]);

    // Find resource row table
    const resource = (eviBundle.resources && eviBundle.resources.find(r => r.name === 'uk_local_authorities_current')) || (eviBundle.resources && eviBundle.resources[0]);
    if (!resource || !resource.data) throw new Error('Could not find resource.data in the EVI JSON');
    const rows = resource.data;

    // Build gss-code -> row lookup
    const rowByGss = new Map();
    rows.forEach(r => {
      if (r['gss-code']) rowByGss.set(r['gss-code'], r);
    });

    // ------------------------
    // ORCS map (deciles) — existing behaviour
    // ------------------------

    // Build ORCS numeric map
    const orcsValueByGss = new Map();
    rows.forEach(r => {
      const gss = r['gss-code'];
      const val = r['ORCS-total-charging-devices'];
      const n = (val === null || val === undefined || val === '') ? NaN : Number(val);
      orcsValueByGss.set(gss, n);
    });

    const orcsValues = Array.from(orcsValueByGss.values()).filter(v => !isNaN(v)).sort((a,b)=>a-b);

    function quantile(sortedArr, p) {
      if (!sortedArr.length) return NaN;
      const idx = (sortedArr.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if (hi === lo) return sortedArr[lo];
      const frac = idx - lo;
      return sortedArr[lo] * (1 - frac) + sortedArr[hi] * frac;
    }

    const orcsThresholds = [];
    if (orcsValues.length) for (let i = 1; i <= 9; i++) orcsThresholds.push(quantile(orcsValues, i / 10));
    const orcsPalette = chroma.scale('YlGnBu').mode('lab').colors(10);

    function orcsDecileIndex(v) {
      if (isNaN(v)) return -1;
      for (let i = 0; i < orcsThresholds.length; i++) if (v <= orcsThresholds[i]) return i;
      return 9;
    }

    // Create ORCS map
    const mapOrcs = L.map('map-orcs').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(mapOrcs);
    window.orcsMap = mapOrcs; // expose for tab invalidation

    const orcsLayer = L.geoJSON(geojson, {
      style(feature) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const v = orcsValueByGss.get(code);
        const idx = orcsDecileIndex(v);
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: idx === -1 ? 0.15 : 0.85,
          fillColor: idx === -1 ? '#cccccc' : orcsPalette[idx]
        };
      },
      onEachFeature(feature, layer) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const name = feature.properties && (feature.properties.LAD24NM || feature.properties.name || 'Unknown');
        const v = orcsValueByGss.get(code);
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>ORCS devices: ${isNaN(v) ? 'N/A' : v}`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            orcsLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapOrcs.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapOrcs);

    // ORCS legend
    const orcsLegend = L.control({ position: 'bottomright' });
    orcsLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'ORCS devices decile legend');
      if (!orcsValues.length) { div.innerHTML = '<strong>ORCS devices</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>ORCS devices (deciles)</strong><br/>';
      let lower = orcsValues[0];
      for (let i = 0; i < 10; i++) {
        const color = orcsPalette[i];
        const upper = (i < 9) ? orcsThresholds[i] : orcsValues[orcsValues.length - 1];
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${Math.round(lower)} – ${Math.round(upper)}`;
        div.appendChild(row);
        lower = (i < 9) ? (orcsThresholds[i] + Number.EPSILON) : upper;
      }
      const nodata = document.createElement('div');
      nodata.className = 'row';
      nodata.style.marginTop = '6px';
      nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
      div.appendChild(nodata);
      return div;
    };
    orcsLegend.addTo(mapOrcs);

    // ------------------------
    // Pavement Channels map (categorical by channel-status)
    // ------------------------

    // Build status mapping (gss -> status) and collect distinct statuses
    const statusByGss = new Map();
    const statusesSet = new Set();
    rows.forEach(r => {
      const gss = r['gss-code'];
      let status = r['channel-status'];
      if (status === null || status === undefined || status === '') status = 'No data';
      // Normalize small whitespace
      status = String(status).trim();
      statusByGss.set(gss, status);
      statusesSet.add(status);
    });

    // Build ordered list of distinct statuses
    const statuses = Array.from(statusesSet).sort();
    console.log('Pavement channel statuses:', statuses);
    // Simple categorical palette (falls back to cycling if more categories than colours)
    const baseColors = [
      '#1f78b4', '#33a02c', '#e31a1c', '#ff7f00',
      '#6a3d9a', '#b15928', '#a6cee3', '#b2df8a',
      '#fb9a99', '#fdbf6f', '#cab2d6', '#ffff99'
    ];
    const statusColor = {};
    statuses.forEach((s, i) => {
      statusColor[s] = baseColors[i % baseColors.length];
    });

    // Create pavement map
    const mapPav = L.map('map-pavement').setView([54.5, -3], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(mapPav);
    window.pavementMap = mapPav;

    const pavLayer = L.geoJSON(geojson, {
      style(feature) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const status = statusByGss.get(code) || 'No data';
        const color = statusColor[status] || '#cccccc';
        return {
          weight: 1,
          color: '#444',
          opacity: 1,
          fillOpacity: status === 'No data' ? 0.15 : 0.85,
          fillColor: color
        };
      },
      onEachFeature(feature, layer) {
        const code = feature.properties && (feature.properties.LAD24CD || feature.properties.gss || feature.properties.gss_code);
        const name = feature.properties && (feature.properties.LAD24NM || feature.properties.name || 'Unknown');
        const status = statusByGss.get(code) || 'No data';
        // include grant amount if present
        const row = rowByGss.get(code) || {};
        const grant = row['channel-grant-amount'];
        const grantLabel = (grant === null || grant === undefined || grant === '') ? '' : `<br/>Grant amount: £${Number(grant).toLocaleString()}`;
        layer.on({
          mouseover(e) {
            const t = e.target;
            t.setStyle({ weight: 2, color: '#000' });
            t.bringToFront();
            const html = `<strong>${name}</strong><br/>Status: ${status}${grantLabel}`;
            t.bindTooltip(html, { sticky: true, direction: 'auto' }).openTooltip();
          },
          mouseout(e) {
            pavLayer.resetStyle(e.target);
            e.target.closeTooltip();
          },
          click(e) {
            mapPav.fitBounds(e.target.getBounds(), { maxZoom: 12 });
          }
        });
      }
    }).addTo(mapPav);

    // Pavement legend — categorical
    const pavLegend = L.control({ position: 'bottomright' });
    pavLegend.onAdd = function () {
      const div = L.DomUtil.create('div', 'legend');
      div.setAttribute('role', 'group');
      div.setAttribute('aria-label', 'Pavement channels status legend');
      if (!statuses.length) { div.innerHTML = '<strong>Pavement channels</strong><br/>No data'; return div; }
      div.innerHTML = '<strong>Pavement channels</strong><br/>';
      statuses.forEach(s => {
        const color = statusColor[s] || '#cccccc';
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = `<span class="swatch" style="background:${color}"></span> ${s}`;
        div.appendChild(row);
      });
      // No data row (if not present in statuses)
      if (!statuses.includes('No data')) {
        const nodata = document.createElement('div');
        nodata.className = 'row';
        nodata.style.marginTop = '6px';
        nodata.innerHTML = `<span class="swatch" style="background:#cccccc"></span> No data`;
        div.appendChild(nodata);
      }
      return div;
    };
    pavLegend.addTo(mapPav);

    // Handle tab show behaviour: invalidate map size after tab is displayed.
    function hookTabInvalidate(tabId, mapObj) {
      const btn = document.getElementById(tabId);
      if (!btn) return;
      btn.addEventListener('click', () => {
        // small delay to allow tab content to become visible
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      });
      // If tab already active on load
      if (btn.classList.contains('tabs__tab--active') || btn.getAttribute('aria-selected') === 'true') {
        setTimeout(() => { try { mapObj.invalidateSize(); } catch (e) {/*ignore*/} }, 200);
      }
    }
    hookTabInvalidate('tab-orcs', mapOrcs);
    hookTabInvalidate('tab-pavement-channels', mapPav);

  } catch (err) {
    console.error(err);
    alert('Map initialization failed: ' + (err && err.message));
  }
})();
</script>

<script type="text/javascript" src="/js/tabs.js"></script>